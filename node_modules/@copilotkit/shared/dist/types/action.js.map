{"version":3,"sources":["../../src/types/action.ts"],"sourcesContent":["type TypeMap = {\n  string: string;\n  number: number;\n  boolean: boolean;\n  object: object;\n  \"string[]\": string[];\n  \"number[]\": number[];\n  \"boolean[]\": boolean[];\n  \"object[]\": object[];\n};\n\nexport type BaseParameter = {\n  name: string;\n  type?: Exclude<keyof TypeMap, \"string\" | \"object\" | \"object[]\">; // Exclude object types for BaseParameter\n  description?: string;\n  required?: boolean;\n};\n\nexport type StringParameter = {\n  name: string;\n  type: \"string\";\n  description?: string;\n  required?: boolean;\n  enum?: string[];\n};\n\nexport type ObjectParameter = {\n  name: string;\n  type: \"object\" | \"object[]\";\n  description?: string;\n  required?: boolean;\n  attributes?: Parameter[];\n};\n\nexport type Parameter = BaseParameter | StringParameter | ObjectParameter;\n\ntype EnumParameterType<E, Required> = E extends string\n  ? Required extends false\n    ? E | undefined\n    : E\n  : never;\n\ntype ObjectTypeParameter<Attributes> = Attributes extends Parameter[]\n  ? MappedParameterTypes<Attributes>\n  : never;\n\ntype ObjectArrayTypeParameter<Attributes> = Attributes extends Parameter[]\n  ? MappedParameterTypes<Attributes>[]\n  : any[];\n\ntype OtherParameterType<Type, Required> = Required extends false\n  ? TypeMap[Type extends keyof TypeMap ? Type : \"string\"] | undefined\n  : TypeMap[Type extends keyof TypeMap ? Type : \"string\"];\n\n// prettier-ignore\nexport type MappedParameterTypes<T extends Parameter[]> = {\n    [P in T[number] as P[\"name\"]]: P extends { enum: Array<infer E> } ? EnumParameterType<E, P[\"required\"]>\n    : P extends { type: \"object\"; attributes: infer Attributes } ? ObjectTypeParameter<Attributes>\n    : P extends { type: \"object[]\"; attributes?: never } ? any[]\n    : P extends { type: \"object[]\"; attributes: infer Attributes } ? ObjectArrayTypeParameter<Attributes>\n    : OtherParameterType<P[\"type\"], P[\"required\"]>;\n};\n\nexport type Action<T extends Parameter[] | [] = []> = {\n  name: string;\n  description?: string;\n  parameters?: T;\n  handler: T extends []\n    ? () => any | Promise<any>\n    : (args: MappedParameterTypes<T>) => any | Promise<any>;\n};\n\n// This is the original \"ceiling is being raised\" version of MappedParameterTypes.\n//\n// ceiling is being raised. cursor's copilot helped us write \"superhuman code\"\n// for a critical feature. We can read this code, but VERY few engineers out\n// there could write it from scratch.\n// Took lots of convincing too. \"come on, this must be possible, try harder\".\n// and obviously- done in parts.\n//\n// - https://twitter.com/ataiiam/status/1765089261374914957\n//   (Mar 5, 2024)\n//\n// export type MappedParameterTypes<T extends Parameter[]> = {\n//   // Check if the parameter has an 'enum' defined\n//   [P in T[number] as P[\"name\"]]: P extends { enum: Array<infer E> }\n//     ? E extends string // Ensure the enum values are strings\n//       ? P[\"required\"] extends false // Check if the parameter is optional\n//         ? E | undefined // If so, include 'undefined' in the type\n//         : E // Otherwise, use the enum type directly\n//       : never // This case should not occur since 'enum' implies string values\n//     : // Handle parameters defined as 'object' with specified attributes\n//     P extends { type: \"object\"; attributes: infer Attributes }\n//     ? Attributes extends Parameter[]\n//       ? MappedParameterTypes<Attributes> // Recursively map the attributes of the object\n//       : never // If 'attributes' is not an array of Parameters, this is invalid\n//     : // Handle parameters defined as 'object[]' without specified attributes\n//     P extends { type: \"object[]\"; attributes?: never }\n//     ? any[] // Default to 'any[]' for arrays of objects without specific attributes\n//     : // Handle parameters defined as 'object[]' with specified attributes\n//     P extends { type: \"object[]\"; attributes: infer Attributes }\n//     ? Attributes extends Parameter[]\n//       ? MappedParameterTypes<Attributes>[] // Recursively map each object in the array\n//       : any[] // Default to 'any[]' if attributes are not properly defined\n//     : // Handle all other parameter types\n//     P[\"required\"] extends false\n//     ? // Include 'undefined' for optional parameters\n//       TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"] | undefined\n//     : // Use the direct mapping from 'TypeMap' for the parameter's type\n//       TypeMap[P[\"type\"] extends keyof TypeMap ? P[\"type\"] : \"string\"];\n// };\n"],"mappings":";;;;;;;;;;;;;;;;AAAA;AAAA;","names":[]}