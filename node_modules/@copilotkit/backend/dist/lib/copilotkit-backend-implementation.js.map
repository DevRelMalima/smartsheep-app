{"version":3,"sources":["../../src/lib/copilotkit-backend-implementation.ts","../../src/utils/openai.ts","../../src/utils/stream.ts","../../src/utils/langserve.ts"],"sourcesContent":["import {\n  Action,\n  ToolDefinition,\n  EXCLUDE_FROM_FORWARD_PROPS_KEYS,\n  actionToChatCompletionFunction,\n  Parameter,\n  AnnotatedFunction,\n  annotatedFunctionToAction,\n} from \"@copilotkit/shared\";\nimport { copilotkitStreamInterceptor, remoteChainToAction } from \"../utils\";\nimport { RemoteChain, CopilotKitServiceAdapter } from \"../types\";\n\ninterface CopilotBackendResult {\n  stream: ReadableStream;\n  headers?: Record<string, string>;\n}\n\ninterface CopilotBackendImplementationConstructorParams {\n  actions?: Action<any>[] | AnnotatedFunction<any>[];\n  langserve?: RemoteChain[];\n  debug?: boolean;\n}\n\nexport class CopilotBackendImplementation {\n  private actions: Action<any>[] = [];\n  private langserve: Promise<Action<any>>[] = [];\n  private debug: boolean = false;\n\n  constructor(params?: CopilotBackendImplementationConstructorParams) {\n    for (const action of params?.actions || []) {\n      if (\"argumentAnnotations\" in action) {\n        this.actions.push(annotatedFunctionToAction(action));\n      } else {\n        this.actions.push(action);\n      }\n    }\n    for (const chain of params?.langserve || []) {\n      this.langserve.push(remoteChainToAction(chain));\n    }\n    this.debug = params?.debug || false;\n  }\n\n  addAction(action: Action<any> | AnnotatedFunction<any>): void {\n    this.removeAction(action.name);\n    if (\"argumentAnnotations\" in action) {\n      this.actions.push(annotatedFunctionToAction(action));\n    } else {\n      this.actions.push(action);\n    }\n  }\n\n  removeAction(actionName: string): void {\n    this.actions = this.actions.filter((f) => f.name !== actionName);\n  }\n\n  removeBackendOnlyProps(forwardedProps: any): void {\n    // Get keys backendOnlyPropsKeys in order to remove them from the forwardedProps\n    const backendOnlyPropsKeys = forwardedProps[EXCLUDE_FROM_FORWARD_PROPS_KEYS];\n    if (Array.isArray(backendOnlyPropsKeys)) {\n      backendOnlyPropsKeys.forEach((key) => {\n        const success = Reflect.deleteProperty(forwardedProps, key);\n        if (!success) {\n          console.error(`Failed to delete property ${key}`);\n        }\n      });\n      // After deleting individual backend-only properties, delete the EXCLUDE_FROM_FORWARD_PROPS_KEYS property itself from forwardedProps\n      const success = Reflect.deleteProperty(forwardedProps, EXCLUDE_FROM_FORWARD_PROPS_KEYS);\n      if (!success) {\n        console.error(`Failed to delete EXCLUDE_FROM_FORWARD_PROPS_KEYS`);\n      }\n    } else if (backendOnlyPropsKeys) {\n      console.error(\"backendOnlyPropsKeys is not an array\");\n    }\n  }\n\n  private async getResponse(\n    forwardedProps: any,\n    serviceAdapter: CopilotKitServiceAdapter,\n  ): Promise<CopilotBackendResult> {\n    this.removeBackendOnlyProps(forwardedProps);\n    const langserveFunctions: Action<any>[] = [];\n\n    for (const chainPromise of this.langserve) {\n      try {\n        const chain = await chainPromise;\n        langserveFunctions.push(chain);\n      } catch (error) {\n        console.error(\"Error loading langserve chain:\", error);\n      }\n    }\n\n    // merge server side functions with langserve functions\n    let mergedTools = mergeServerSideTools(\n      this.actions.map(actionToChatCompletionFunction),\n      langserveFunctions.map(actionToChatCompletionFunction),\n    );\n\n    // merge with client side functions\n    mergedTools = mergeServerSideTools(mergedTools, forwardedProps.tools);\n\n    try {\n      const result = await serviceAdapter.getResponse({\n        ...forwardedProps,\n        tools: mergedTools,\n      });\n      const stream = copilotkitStreamInterceptor(\n        result.stream,\n        [...this.actions, ...langserveFunctions],\n        this.debug,\n      );\n      return { stream, headers: result.headers };\n    } catch (error) {\n      console.error(\"Error getting response:\", error);\n      throw error;\n    }\n  }\n\n  async response(req: Request, serviceAdapter: CopilotKitServiceAdapter): Promise<Response> {\n    try {\n      const response = await this.getResponse(await req.json(), serviceAdapter);\n      return new Response(response.stream, { headers: response.headers });\n    } catch (error: any) {\n      return new Response(\"\", { status: 500, statusText: error.message });\n    }\n  }\n\n  async streamHttpServerResponse(\n    req: any,\n    res: any,\n    serviceAdapter: CopilotKitServiceAdapter,\n    headers?: Record<string, string>,\n  ) {\n    const bodyParser = new Promise<any>((resolve, reject) => {\n      if (\"body\" in req) {\n        resolve(req.body);\n        return;\n      }\n      let body = \"\";\n      req.on(\"data\", (chunk: any) => (body += chunk.toString()));\n      req.on(\"end\", () => {\n        try {\n          resolve(JSON.parse(body));\n        } catch (error) {\n          reject(error);\n        }\n      });\n    });\n    const forwardedProps = await bodyParser;\n    const response = await this.getResponse(forwardedProps, serviceAdapter);\n    const mergedHeaders = { ...headers, ...response.headers };\n    res.writeHead(200, mergedHeaders);\n    const stream = response.stream;\n    const reader = stream.getReader();\n\n    while (true) {\n      const { done, value } = await reader.read();\n      if (done) {\n        res.end();\n        break;\n      } else {\n        res.write(new TextDecoder().decode(value));\n      }\n    }\n  }\n}\n\nexport function mergeServerSideTools(\n  serverTools: ToolDefinition[],\n  clientTools?: ToolDefinition[],\n) {\n  let allTools: ToolDefinition[] = serverTools.slice();\n  const serverToolsNames = serverTools.map((tool) => tool.function.name);\n  if (clientTools) {\n    allTools = allTools.concat(\n      // filter out any client functions that are already defined on the server\n      clientTools.filter((tool: ToolDefinition) => !serverToolsNames.includes(tool.function.name)),\n    );\n  }\n  return allTools;\n}\n","import { Message, ToolDefinition, ChatCompletionChunk, encodeResult } from \"@copilotkit/shared\";\n\nexport function writeChatCompletionChunk(\n  controller: ReadableStreamDefaultController<any>,\n  chunk: ChatCompletionChunk,\n) {\n  const payload = new TextEncoder().encode(\"data: \" + JSON.stringify(chunk) + \"\\n\\n\");\n  controller!.enqueue(payload);\n}\n\nexport function writeChatCompletionContent(\n  controller: ReadableStreamDefaultController<any>,\n  content: string = \"\",\n  toolCalls?: any,\n) {\n  const chunk: ChatCompletionChunk = {\n    choices: [\n      {\n        delta: {\n          role: \"assistant\",\n          content: content,\n          ...(toolCalls ? { tool_calls: toolCalls } : {}),\n        },\n      },\n    ],\n  };\n\n  writeChatCompletionChunk(controller, chunk);\n}\n\nexport function writeChatCompletionResult(\n  controller: ReadableStreamDefaultController<any>,\n  functionName: string,\n  result: any,\n) {\n  let resultString = encodeResult(result);\n\n  const chunk: ChatCompletionChunk = {\n    choices: [\n      {\n        delta: {\n          role: \"function\",\n          content: resultString,\n          name: functionName,\n        },\n      },\n    ],\n  };\n\n  writeChatCompletionChunk(controller, chunk);\n}\n\nexport function writeChatCompletionEnd(controller: ReadableStreamDefaultController<any>) {\n  const payload = new TextEncoder().encode(\"data: [DONE]\\n\\n\");\n  controller.enqueue(payload);\n}\n\nexport function limitOpenAIMessagesToTokenCount(\n  messages: Message[],\n  tools: ToolDefinition[],\n  maxTokens: number,\n): Message[] {\n  const result: Message[] = [];\n  const toolsNumTokens = countToolsTokens(tools);\n  if (toolsNumTokens > maxTokens) {\n    throw new Error(`Too many tokens in function definitions: ${toolsNumTokens} > ${maxTokens}`);\n  }\n  maxTokens -= toolsNumTokens;\n\n  for (const message of messages) {\n    if (message.role === \"system\") {\n      const numTokens = countMessageTokens(message);\n      maxTokens -= numTokens;\n\n      if (maxTokens < 0) {\n        throw new Error(\"Not enough tokens for system message.\");\n      }\n    }\n  }\n\n  let cutoff: boolean = false;\n\n  const reversedMessages = [...messages].reverse();\n  for (const message of reversedMessages) {\n    if (message.role === \"system\") {\n      result.unshift(message);\n      continue;\n    } else if (cutoff) {\n      continue;\n    }\n    let numTokens = countMessageTokens(message);\n    if (maxTokens < numTokens) {\n      cutoff = true;\n      continue;\n    }\n    result.unshift(message);\n    maxTokens -= numTokens;\n  }\n\n  return result;\n}\n\nexport function maxTokensForOpenAIModel(model: string): number {\n  return maxTokensByModel[model] || DEFAULT_MAX_TOKENS;\n}\n\nconst DEFAULT_MAX_TOKENS = 8192;\n\nconst maxTokensByModel: { [key: string]: number } = {\n  // GPT-4\n  \"gpt-4-0125-preview\": 128000,\n  \"gpt-4-turbo-preview\": 128000,\n  \"gpt-4-1106-preview\": 128000,\n  \"gpt-4-vision-preview\": 128000,\n  \"gpt-4-1106-vision-preview\": 128000,\n  \"gpt-4-32k\": 32768,\n  \"gpt-4-32k-0613\": 32768,\n  \"gpt-4-32k-0314\": 32768,\n  \"gpt-4\": 8192,\n  \"gpt-4-0613\": 8192,\n  \"gpt-4-0314\": 8192,\n\n  // GPT-3.5\n  \"gpt-3.5-turbo-0125\": 16385,\n  \"gpt-3.5-turbo\": 16385,\n  \"gpt-3.5-turbo-1106\": 16385,\n  \"gpt-3.5-turbo-instruct\": 4096,\n  \"gpt-3.5-turbo-16k\": 16385,\n  \"gpt-3.5-turbo-0613\": 4096,\n  \"gpt-3.5-turbo-16k-0613\": 16385,\n  \"gpt-3.5-turbo-0301\": 4097,\n};\n\nfunction countToolsTokens(functions: ToolDefinition[]): number {\n  if (functions.length === 0) {\n    return 0;\n  }\n  const json = JSON.stringify(functions);\n  return countTokens(json);\n}\n\nfunction countMessageTokens(message: Message): number {\n  if (message.content) {\n    return countTokens(message.content);\n  } else if (message.function_call) {\n    return countTokens(JSON.stringify(message.function_call));\n  }\n  return 0;\n}\n\nfunction countTokens(text: string): number {\n  return text.length / 3;\n}\n","import { Action, parseChatCompletion } from \"@copilotkit/shared\";\nimport {\n  writeChatCompletionChunk,\n  writeChatCompletionContent,\n  writeChatCompletionEnd,\n  writeChatCompletionResult,\n} from \"./openai\";\n\n/**\n * Execute a function call and write the result to the stream.\n * TODO: should this return a stream to get process other function calls?\n */\nasync function executeFunctionCall(\n  controller: ReadableStreamDefaultController<any>,\n  action: Action<any>,\n  functionCallArguments: string,\n): Promise<void> {\n  // Prepare arguments for function calling\n  let args: Record<string, any>[] = [];\n  if (functionCallArguments) {\n    args = JSON.parse(functionCallArguments);\n  }\n\n  // call the function\n  const result = await action.handler(args);\n\n  // We support several types of return values from functions:\n\n  // 1. string\n  // Just send the result as the content of the chunk.\n  if (typeof result === \"string\") {\n    writeChatCompletionResult(controller, action.name, result);\n  }\n\n  // 2. AIMessage\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (\"content\" in result && typeof result.content === \"string\") {\n    writeChatCompletionContent(controller, result.content, result.additional_kwargs?.tool_calls);\n  }\n\n  // 3. BaseMessageChunk\n  // Send the content and function call of the AIMessage as the content of the chunk.\n  else if (\"lc_kwargs\" in result) {\n    writeChatCompletionContent(controller, result.lc_kwargs?.content, result.lc_kwargs?.tool_calls);\n  }\n\n  // 4. IterableReadableStream\n  // Stream the result of the LangChain function.\n  else if (\"getReader\" in result) {\n    let reader = result.getReader();\n    while (true) {\n      try {\n        const { done, value } = await reader.read();\n\n        if (done) {\n          break;\n        }\n\n        writeChatCompletionContent(\n          controller,\n          value?.lc_kwargs?.content,\n          value.lc_kwargs?.additional_kwargs?.tool_calls,\n        );\n      } catch (error) {\n        console.error(\"Error reading from stream\", error);\n        break;\n      }\n    }\n  }\n\n  // 5. Any other type, return JSON result\n  else {\n    writeChatCompletionResult(controller, action.name, result);\n  }\n}\n\n/**\n * This function decides what to handle server side and what to forward to the client.\n * It also handles the execution of server side functions.\n *\n * TODO: add proper error handling and logging\n */\nexport function copilotkitStreamInterceptor(\n  stream: ReadableStream<Uint8Array>,\n  actions: Action<any>[],\n  debug: boolean = false,\n): ReadableStream {\n  const functionsByName = actions.reduce((acc, fn) => {\n    acc[fn.name] = fn;\n    return acc;\n  }, {} as Record<string, Action<any>>);\n\n  const decodedStream = parseChatCompletion(stream);\n  const reader = decodedStream.getReader();\n\n  async function cleanup(controller?: ReadableStreamDefaultController<any>) {\n    if (controller) {\n      try {\n        controller.close();\n      } catch (_) {}\n    }\n    if (reader) {\n      try {\n        await reader.cancel();\n      } catch (_) {}\n    }\n  }\n\n  // Keep track of current state as we process the stream\n\n  // Loop Invariant:\n  // Either we are in the middle of a function call that should be executed on the backend = TRUE\n  // or we are in the middle of processing a chunk that should be forwarded to the client = FALSE\n  let executeThisFunctionCall = false;\n\n  let functionCallName = \"\";\n  let functionCallArguments = \"\";\n\n  let currentFnIndex = 0;\n\n  const flushFunctionCall = async (\n    controller: ReadableStreamDefaultController<any>,\n  ): Promise<void> => {\n    const action = functionsByName[functionCallName];\n    await executeFunctionCall(controller, action, functionCallArguments);\n\n    executeThisFunctionCall = false;\n    functionCallName = \"\";\n    functionCallArguments = \"\";\n  };\n\n  return new ReadableStream({\n    async pull(controller) {\n      while (true) {\n        try {\n          const { done, value } = await reader.read();\n          if (done) {\n            if (debug) {\n              console.log(\"data: [DONE]\\n\\n\");\n            }\n            if (executeThisFunctionCall) {\n              // We are at the end of the stream and still have a function call to execute\n              await flushFunctionCall(controller);\n            }\n            writeChatCompletionEnd(controller);\n            await cleanup(controller);\n            return;\n          } else if (debug) {\n            console.log(\"data: \" + JSON.stringify(value) + \"\\n\\n\");\n          }\n\n          let mode: \"function\" | \"message\" = value.choices[0].delta.tool_calls\n            ? \"function\"\n            : \"message\";\n\n          const index = (value.choices[0].delta.tool_calls?.[0]?.index || 0) as number;\n\n          // We are in the middle of a function call and got a non function call chunk\n          // or a different function call\n          // => execute the function call first\n          if (executeThisFunctionCall && (mode != \"function\" || index != currentFnIndex)) {\n            await flushFunctionCall(controller);\n          }\n\n          currentFnIndex = index;\n\n          // if we get a message, emit the content and continue;\n          if (mode === \"message\") {\n            if (value.choices[0].delta.content) {\n              writeChatCompletionChunk(controller, value);\n            }\n            continue;\n          }\n          // if we get a function call, emit it only if we don't execute it server side\n          else if (mode === \"function\") {\n            // Set the function name if present\n            if (value.choices[0].delta.tool_calls?.[0]?.function?.name) {\n              functionCallName = value.choices[0].delta.tool_calls![0].function.name!;\n            }\n            // If we have argument streamed back, add them to the function call arguments\n            if (value.choices[0].delta.tool_calls?.[0]?.function?.arguments) {\n              functionCallArguments += value.choices[0].delta.tool_calls![0].function.arguments!;\n            }\n            if (!executeThisFunctionCall) {\n              // Decide if we should execute the function call server side\n              if (functionCallName in functionsByName) {\n                executeThisFunctionCall = true;\n              }\n            }\n\n            if (value.choices[0].delta.tool_calls) {\n              // To avoid the client executing the function call as well, we set the scope to \"server\"\n              value.choices[0].delta.tool_calls[0].function.scope = executeThisFunctionCall\n                ? \"server\"\n                : \"client\";\n            }\n            writeChatCompletionChunk(controller, value);\n            continue;\n          }\n        } catch (error) {\n          controller.error(error);\n          return;\n        }\n      }\n    },\n    cancel() {\n      reader.cancel();\n    },\n  });\n}\n","import { Action } from \"@copilotkit/shared\";\nimport { RemoteChain } from \"../types\";\nimport { RemoteRunnable } from \"langchain/runnables/remote\";\n\nexport async function remoteChainToAction(chain: RemoteChain): Promise<Action<any>> {\n  chain = { ...chain };\n  const runnable = new RemoteRunnable({ url: chain.chainUrl });\n\n  if (!chain.parameters) {\n    chain = await inferLangServeParameters(chain);\n  }\n\n  chain.parameterType ||= \"multi\";\n\n  return {\n    name: chain.name,\n    description: chain.description,\n    parameters: chain.parameters!,\n    handler: async (args: any) => {\n      let input: any;\n      if (chain.parameterType === \"single\") {\n        input = args[Object.keys(args)[0]];\n      } else {\n        input = args;\n      }\n      return await runnable.invoke(input);\n    },\n  };\n}\n\nexport async function inferLangServeParameters(chain: RemoteChain): Promise<RemoteChain> {\n  chain = { ...chain };\n\n  const supportedTypes = [\"string\", \"number\", \"boolean\"];\n\n  let schemaUrl = chain.chainUrl.replace(/\\/+$/, \"\") + \"/input_schema\";\n  let schema = await fetch(schemaUrl)\n    .then((res) => res.json())\n    .catch(() => {\n      throw new Error(\"Failed to fetch langserve schema at \" + schemaUrl);\n    });\n  // for now, don't use json schema, just do a simple conversion\n\n  if (supportedTypes.includes(schema.type)) {\n    chain.parameterType = \"single\";\n    chain.parameters = [\n      {\n        name: \"input\",\n        type: schema.type,\n        description: \"The input to the chain\",\n      },\n    ];\n  } else if (schema.type === \"object\") {\n    chain.parameterType = \"multi\";\n    chain.parameters = Object.keys(schema.properties).map((key) => {\n      let property = schema.properties[key];\n      if (!supportedTypes.includes(property.type)) {\n        throw new Error(\"Unsupported schema type\");\n      }\n      return {\n        name: key,\n        type: property.type,\n        description: property.description || \"\",\n        required: schema.required?.includes(key) || false,\n      };\n    });\n  } else {\n    throw new Error(\"Unsupported schema type\");\n  }\n\n  return chain;\n}\n"],"mappings":"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","names":["import_shared","import_shared","success"]}