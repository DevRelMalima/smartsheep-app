{"version":3,"sources":["../src/hooks/use-copilot-action-implementation.ts"],"sourcesContent":["import { useRef, useContext, useEffect } from \"react\";\nimport { FrontendAction } from \"../types/frontend-action\";\nimport { CopilotContext } from \"../context/copilot-context\";\nimport { nanoid } from \"nanoid\";\n\n// We implement useCopilotActionImplementation dependency handling so that\n// the developer has the option to not provide any dependencies.\n// In this case, we assume they want to update the handler on each rerender.\n// To avoid getting stuck in an infinite loop, we update the handler directly,\n// skipping React state updates.\n// This is ok in this case, because the handler is not part of any UI that\n// needs to be updated.\n// useCallback, useMemo or other memoization techniques are not suitable here,\n// because they will cause a infinite rerender loop.\nexport function useCopilotActionImplementation<T extends Array<any> = []>(\n  action: FrontendAction<T>,\n  dependencies?: any[],\n): void {\n  const { setEntryPoint, removeEntryPoint, entryPoints, chatComponentsCache } =\n    useContext(CopilotContext);\n  const idRef = useRef<string>(nanoid());\n\n  // If the developer doesn't provide dependencies, we assume they want to\n  // update handler and render function when the action object changes.\n  // This ensures that any captured variables in the handler are up to date.\n  if (dependencies === undefined) {\n    if (entryPoints[idRef.current]) {\n      entryPoints[idRef.current].handler = action.handler;\n      if (typeof action.render === \"function\") {\n        if (chatComponentsCache.current !== null) {\n          chatComponentsCache.current[action.name] = action.render;\n        }\n      }\n    }\n  }\n\n  useEffect(() => {\n    setEntryPoint(idRef.current, action);\n    if (chatComponentsCache.current !== null && action.render !== undefined) {\n      chatComponentsCache.current[action.name] = action.render;\n    }\n    return () => {\n      // NOTE: For now, we don't remove the chatComponentsCache entry when the action is removed.\n      // This is because we currently don't have access to the messages array in CopilotContext.\n      removeEntryPoint(idRef.current);\n    };\n  }, [\n    setEntryPoint,\n    removeEntryPoint,\n    action.description,\n    action.name,\n    // This should be faster than deep equality checking\n    // In addition, all major JS engines guarantee the order of object keys\n    JSON.stringify(action.parameters),\n    // include render only if it's a string\n    typeof action.render === \"string\" ? action.render : undefined,\n    // dependencies set by the developer\n    ...(dependencies || []),\n  ]);\n}\n"],"mappings":";;;;;AAAA,SAAS,QAAQ,YAAY,iBAAiB;AAG9C,SAAS,cAAc;AAWhB,SAAS,+BACd,QACA,cACM;AACN,QAAM,EAAE,eAAe,kBAAkB,aAAa,oBAAoB,IACxE,WAAW,cAAc;AAC3B,QAAM,QAAQ,OAAe,OAAO,CAAC;AAKrC,MAAI,iBAAiB,QAAW;AAC9B,QAAI,YAAY,MAAM,OAAO,GAAG;AAC9B,kBAAY,MAAM,OAAO,EAAE,UAAU,OAAO;AAC5C,UAAI,OAAO,OAAO,WAAW,YAAY;AACvC,YAAI,oBAAoB,YAAY,MAAM;AACxC,8BAAoB,QAAQ,OAAO,IAAI,IAAI,OAAO;AAAA,QACpD;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAEA,YAAU,MAAM;AACd,kBAAc,MAAM,SAAS,MAAM;AACnC,QAAI,oBAAoB,YAAY,QAAQ,OAAO,WAAW,QAAW;AACvE,0BAAoB,QAAQ,OAAO,IAAI,IAAI,OAAO;AAAA,IACpD;AACA,WAAO,MAAM;AAGX,uBAAiB,MAAM,OAAO;AAAA,IAChC;AAAA,EACF,GAAG;AAAA,IACD;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP,OAAO;AAAA;AAAA;AAAA,IAGP,KAAK,UAAU,OAAO,UAAU;AAAA;AAAA,IAEhC,OAAO,OAAO,WAAW,WAAW,OAAO,SAAS;AAAA;AAAA,IAEpD,GAAI,gBAAgB,CAAC;AAAA,EACvB,CAAC;AACH;","names":[]}